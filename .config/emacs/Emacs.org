#+TITLE: Emacs configuration
#+AUTHOR: Andrea Orione
#+DESCRIPTION: My personal configuration (still work in progress)
#+STARTUP: showeverything
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes

* Startup Performance

#+begin_src emacs-lisp

;; The default is 800 kilobytes.  Measured in bytes.
(setq gc-cons-threshold (* 50 1000 1000))

(defun efs/display-startup-time ()
  (message "Emacs loaded in %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                     (time-subtract after-init-time before-init-time)))
           gcs-done))

(add-hook 'emacs-startup-hook #'efs/display-startup-time)

#+end_src

* Hiding unnecessary stuff
Emacs sets some variables by default and lets you modify them throught a visual editor, then stores their values in the init.el file. Since we are not using this system we want to hide those variables in another file. This is achieved with the following snippet.

#+begin_src emacs-lisp

(setq custom-file "~/.config/emacs/custom.el")
(load custom-file)

#+end_src

* Use-package setup
Setting up use-package. This package simplifies life when comes to importing other packages and configuring them.

#+begin_src emacs-lisp

;; Initializing packge source
(require 'package)

(setq package-archives '(("melpa" . "https://melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")
                         ("elpa" . "https://elpa.gnu.org/packages/")))

(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))

;; Initialize use-package on non-Linux platforms
(unless (package-installed-p 'use-package)
  (package-install 'use-package))

(require 'use-package)
(setq use-package-always-ensure t)      ;; Install the package if it is not already

#+end_src

** Automatic Package Updates
The auto-package-update package helps us keep our Emacs packages up to date!  It will prompt you after a certain number of days either at startup or at a specific time of day to remind you to update your packages.

You can also use =M-x auto-package-update-now= to update right now!

#+begin_src emacs-lisp

(use-package auto-package-update
  :custom
  (auto-package-update-interval 7)
  (auto-package-update-prompt-before-update t)
  (auto-package-update-hide-results t)
  :config
  (auto-package-update-maybe)
  (auto-package-update-at-time "09:00"))

#+end_src

* Basic UI Configuration
In this section we are going to set some basic UI variables to make Emacs look more minimal (and dark).

#+begin_src emacs-lisp

;;(setq inhibit-startup-message t) ;;I'm going to disable it when I set up a dash

;;(scroll-bar-mode -1)       ; Disable visible scrollbar ;; For now I'll keep it :)
(tool-bar-mode -1)         ; Disable the toolbar
(tooltip-mode -1)          ; Disable tooltips
(set-fringe-mode 0)        ; Disabel space from the border

(menu-bar-mode -1)         ; Disable the menu bar

(setq visible-bell t)      ; Set up the visible bell

(column-number-mode)
(global-display-line-numbers-mode t)

;; Disable line number for some modes
(dolist (mode '(org-mode-hook
		term-mode-hook
		shell-mode-hook
               treemacs-mode-hook
		eshell-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))

#+end_src

** Font configuration
Here we configure the fonts. The size must be adjusted dependinding on the dpi of the screen

#+begin_src emacs-lisp

(defvar orion/default-font-size 128)
(defvar orion/default-variable-font-size 128)

;;(set-face-attribute 'default nil :font "Ubuntu Mono" :height orion/default-font-size)

;;(set-face-attribute 'fixed-pitch nil :font "Ubuntu Mono" :height 140)

;;;(set-face-attribute 'variable-pitch nil :font "Cantarell" :height 170 :weight 'regular)

#+end_src

* Keybinding configuration
Configuration of Vi keybindings with evil-mode. General il used for configuring custom keybindings.

#+begin_src emacs-lisp

(use-package general
  :after evil
  :config
  (general-create-definer orion/leader-keys
    :keymaps '(normal insert visual emacs)
    :prefix "SPC"
    :global-prefix "C-SPC")

  (orion/leader-keys
    "t"  '(:ignore t :which-key "toggles")
    "tt" '(counsel-load-theme :which-key "choose theme")))

(use-package evil
  :init
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  (setq evil-want-C-u-scroll t)
  (setq evil-want-C-i-jump nil)
  ;;:hook (evil-mode . rune/evil-hook)
  :config
  (evil-mode 1)
  (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
  (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backwarh-char-and-join)

  (evil-global-set-key 'motion "j" 'evil-next-visual-line)
  (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

  (evil-set-initial-state 'messages-buffer-mode 'normal)
  (evil-set-initial-state 'dashboard-mode 'normal))

(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))

#+end_src

* UI Packages
** Command log mode
This package can be used to display a panel showing the pressed keybindings with the corresponding action. It is useful for streams. I disable it since i don't use it.

#+begin_src emacs-lisp

;;(use-package command-log-mode
;;  :commands command-log-mode)

#+end_src

** Color Theme
We use the doom-theme package since it has beautiful color themes

#+begin_src emacs-lisp

(use-package doom-themes)
(load-theme 'orion-blue t)
;;(load-theme 'doom-dracula t)
;;(load-theme 'doom-dark+ t)
;;(load-theme 'doom-one t)
;;(load-theme 'doom-monokai-classic t)
;;(load-theme 'doom-solarized-dark t)
;;(load-theme 'doom-tomorrow-night t)

#+end_src

** Modeline
We use doom-modeline as a sobstitute for the plain modeline. To use its full power we need the icon pack all-the-icons.
*NOTE:* the first time you load your configuration on a new machine. you'll need to run `M-x all-the-icons-install-fonts` to download the icons needed.

#+begin_src emacs-lisp

(use-package all-the-icons)

(use-package doom-modeline
  :init (doom-modeline-mode 1))

#+end_src

** Which key
which-key is a package that displays a panel when you start a keybinding to display all the possible completions.

#+begin_src emacs-lisp

(use-package which-key
  :defer 0
  :diminish which-key-mode
  :config
  (which-key-mode)
  (setq which-key-idle-delay 0.4))  ;; Delay before the panel is shown since the key was pressed

#+end_src

** Ivy and Counsel
Ivy is a completion framework.  It provides a menu when you open files, switch buffer and other tasks. Counsel is a replacement for the vanilla commands e.g. replaces `find-file` with `counsel-find-file` adding extra features.
Ivy-rich adds extra columns to the counsel commands to provide more information about them.

#+begin_src emacs-lisp

(use-package ivy
  :diminish
  :bind (("C-s" . swiper)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ("C-d" . ivy-reverse-i-search-kill))
  :config
  (ivy-mode 1))

(use-package ivy-rich
  :after ivy
  :init
  (ivy-rich-mode 1))

(use-package counsel
  :bind (("M-x" . counsel-M-x)
	 ("C-x b" . counsel-ibuffer)
	 ("C-x C-f" . counsel-find-file)
	 :map minibuffer-local-map
	 ("C-r" . 'counsel-minibuffer-history)))

#+end_src

** Helpful commands
Helpful adds informations to the describe- command buffers. It also displays the source code of the functions.

#+begin_src emacs-lisp

(use-package helpful
  :commands (helpful-callable helpful-variable helpful-command helpful-key)
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . counsel-describe-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . counsel-describe-variable)
  ([remap describe-key] . helpful-key))

#+end_src

** Text scaling
Here the package Hydra will be used to create a keybinding box to adjust the scale of the text

#+begin_src emacs-lisp

(use-package hydra
  :defer t)

(defhydra hydra-text-scale (:timeout 4)
  "scale text"
  ("j" text-scale-increase "in")
  ("k" text-scale-decrease "out")
  ("f" nil "finished" :exit t))

(orion/leader-keys
  "ts" '(hydra-text-scale/body :which-key "scale text"))

#+end_src

* Org Mode
** Font configuration
Here will be defined the =orion/org-font-setup= function that configures the text faces of =org-mode=

#+begin_src emacs-lisp

(defun orion/org-font-setup ()
  ;; Replace list hyphen with dot
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

  ;; Set faces for heading levels
  (dolist (face '((org-level-1 . 1.2)
                  (org-level-2 . 1.1)
                  (org-level-3 . 1.05)
                  (org-level-4 . 1.0)
                  (org-level-5 . 1.1)
                  (org-level-6 . 1.1)
                  (org-level-7 . 1.1)
                  (org-level-8 . 1.1)))
    (set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))

  ;; Ensure that anything that should be fixed-pitch in Org files appears that way
  (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))

#+end_src

** Basic configuration
Thies section contains the configuration for =org-mode= 

#+begin_src emacs-lisp

(defun orion/org-mode-setup ()
  (org-indent-mode)
  (variable-pitch-mode 1)
  (auto-fill-mode 0)
  (visual-line-mode 1)
  (setq evil-auto-indent nil))


(use-package org
  :hook (org-mode . orion/org-mode-setup)
  :config
  (setq org-ellipsis " ▾")

  (setq org-agenda-start-with-log-mode t)
  (orion/org-font-setup)
  (setq org-agenda-files
	'("~/.config/emacs/tasks/task.org")))

#+end_src

*** Bullets
org-bullest replaces the heading stars in org-mode buffers

#+begin_src emacs-lisp

(use-package org-bullets
  :after org
  :hook (org-mode . org-bullets-mode)
  :custom
  (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

#+end_src

*** Centered buffer
We are going te use visual fill column te center =org-mode= buffers

#+begin_src emacs-lisp

(defun orion/org-mode-visual-fill ()
  (setq visual-fill-column-width 100
        visual-fill-column-center-text t)
  (visual-fill-column-mode 1))

(use-package visual-fill-column
  :hook (org-mode . orion/org-mode-visual-fill))

#+end_src

** Configure babel languages
 #+begin_src emacs-lisp

(org-babel-do-load-languages
  'org-babel-load-languages
  '((emacs-lisp . t)
    (python . t)))

(setq org-confirma-babel-evaluate nil)

#+end_src

** Configure source bloks

#+begin_src emacs-lisp

(require 'org-tempo)

(add-to-list 'org-structure-template-alist '("sh" . "src shell"))
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("py" . "src python"))
(add-to-list 'org-structure-template-alist '("cpp" . "src cpp"))

(defun orion/org-babel-tangle-config()
  (when (string-equal (buffer-file-name)
                      (expand-file-name "~/.config/emacs/Emacs.org"))
    (let ((org-confirm-babel-evaluate nil))
      (org-babel-tangle))))

(add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'orion/org-babel-tangle-config)))

#+end_src

* Development
** Projectile
Projectile is a project manager that makes a lot easier to navigate around projects. There are lots of packages that integrate with projectile, so it is useful to have it installed even if not used

#+begin_src emacs-lisp

(use-package projectile
  :diminish projectile-mode
  :config (projectile-mode)
  :custom ((projectile-complition-system 'ivy))
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :init
  (when (file-directory-p "~/Projects/Code")
    (setq projectile-project-search-path '("~/Projects/Code")))
  (setq projectile-switch-project-action #'projectile-dired))

(use-package counsel-projectile
  :after projectile
  :config (counsel-projectile-mode))

#+end_src

** Magit
Magit is a package to interface with Git, executing operations from a dedicated panel

#+begin_src emacs-lisp

(use-package magit
  :commands magit-status
  :custom
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

#+end_src

** Rainbow delimiters
This is a minor mode that colorizes nested parentheses following the color scheme in use.

#+begin_src emacs-lisp

(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))

#+end_src

** Commenting
Emacs’ built in commenting functionality comment-dwim (usually bound to M-;) doesn’t always comment things in the way you might expect so we use evil-nerd-commenter to provide a more familiar behavior. I’ve bound it to M-/ since other editors sometimes use this binding but you could also replace Emacs’ M-; binding with this command.

#+begin_src emacs-lisp

(use-package evil-nerd-commenter
  :bind ("M-/" . evilnc-comment-or-uncomment-lines))

#+end_src

** Lsp mode
*** Language Servers

#+begin_src emacs-lisp

(defun orion/lsp-mode-setup ()
  (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
  (lsp-headerline-breadcrumb-mode))

(use-package lsp-mode
  :commands (lsp lsp-deferred)
  :hook (lsp-mode . orion/lsp-mode-setup)
  :init
  (setq lsp-keymap-prefix "C-c l") ;;Or 'C-l', 's-l'
  :config
  (lsp-enable-which-key-integration t))

;;Introduce more ui improves such as sideline
(use-package lsp-ui
  :hook (lsp-mode . lsp-ui-mode)
  :custom
  (lsp-ui-doc-position 'bottom))

#+end_src

*** TypeScript

#+begin_src emacs-lisp

(use-package typescript-mode
  :mode "\\.ts\\'"
  :hook (typescript-mode . lsp-deferred)
  :config
  (setq typescript-indent-level 2))

#+end_src

*** C++

#+begin_src emacs-lisp

#+end_src

** Company Mode
Company mode is a package that shows a box for autocomplition (in this case provided by lsp)

#+begin_src emacs-lisp

(use-package company
  :after lsp-mode
  :hook (lsp-mode . company-mode)
  :bind (:map company-active-map
         ("<tab>" . company-complete-selection))
        (:map lsp-mode-map
         ("<tab>" . company-indent-or-complete-common))
  :custom
  (company-minimum-prefix-length 1)
  (company-idle-delay 0.0))

(use-package company-box
  :hook (company-mode . company-box-mode))

#+end_src

** Treemacs
lsp-treemacs provides tree views for different aspects of your project such as files or objects.
Some useful commands are (to use with =M-x=)
- =lsp-treemacs-symbols=
- =lsp-treemacs-references=
- =lsp-treemacs-error-list=

#+begin_src emacs-lisp

(use-package lsp-treemacs
  :after lsp)

#+end_src

** Lsp-ivy
lsp-ivy allows to search more easily for symbols inside a project. Some useful commands are
- =lsp-ivy-workspace-symbol=
- =lsp-ivy-global-workspace-symbol=

#+begin_src emacs-lisp

(use-package lsp-ivy
  :after ivy)

#+end_src

** Rainbow mode
Rainbow mode hilights the colors with the corresponding tonality. To use it simply do
=M-x rainbow-mode=

#+begin_src emacs-lisp

(use-package rainbow-mode)

#+end_src

* Terminal
** term-mode
Term mode is a terminal emulator written in Emacs Lisp (so it could be slow).
One important thing to understand is =line-mode= versus =char-mode=. =line-mode= enables you to use normal Emacs keybindings while moving around in the terminal buffer while =char-mode= sends most of your keypresses to the underlying terminal. While using term-mode, you will want to be in =char-mode= for any terminal applications that have their own keybindings. If you’re just in your usual shell, =line-mode= is sufficient and feels more integrated with Emacs.

With =evil-collection= installed, you will automatically switch to =char-mode= when you enter Evil’s insert mode (press =i=). You will automatically be switched back to =line-mode= when you enter Evil’s normal mode (press =ESC=).

Run a terminal with =M-x term!=

Useful key bindings:

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer’s prompts (also =[[= and =]]= with evil-mode)
- =C-c C-k= - Enter char-mode
- =C-c C-j= - Return to line-mode
- If you have evil-collection installed, term-mode will enter char mode when you use Evil’s Insert mode


#+begin_src emacs-lisp

(use-package term
  :commands term
  :config
  (setq explicit-shell-file-name "bash") ;; Change this to zsh, etc
  ;;(setq explicit-zsh-args '())         ;; Use 'explicit-<shell>-args for shell-specific args
  ;; Match the default Bash shell prompt.  Update this if you have a custom prompt
  (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))

#+end_src

*** Better Colors
The =eterm-256color= package enhances the output of =term-mode= to enable handling of a wider range of color codes so that many popular terminal applications look as you would expect them to. Keep in mind that this package requires =ncurses= to be installed on your machine so that it has access to the =tic= program. Most Linux distributions come with this program installed already so you may not have to do anything extra to use it.

#+begin_src emacs-lisp

(use-package eterm-256color
  :hook (term-mode . eterm-256color-mode))

#+end_src

** vterm
=vterm= is an improved terminal emulator package which uses a compiled native module to interact with the underlying terminal applications. This enables it to be much faster than =term-mode= and to also provide a more complete terminal emulation experience.

Make sure that you have the [[https://github.com/akermu/emacs-libvterm/#requirements][necessary dependencies]] dependencies installed before trying to use =vterm= because there is a module that will need to be compiled before you can use it successfully.

#+begin_src emacs-lisp

(use-package vterm
  :commands vterm
  :config
  (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")  ;; Set this to match your custom shell prompt
  ;;(setq vterm-shell "zsh")                       ;; Set this to customize the shell to launch
  (setq vterm-max-scrollback 10000))

#+end_src

** shell-mode
=shell-mode= is a middle ground between =term-mode= and Eshell.  It is *not* a terminal emulator so more complex terminal programs will not run inside of it.  It does have much better integration with Emacs because all command input in this mode is handled by Emacs and then sent to the underlying shell once you press Enter.  This means that you can use =evil-mode='s editing motions on the command line, unlike in the terminal emulator modes above.

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-shell-history= - A searchable history of commands typed into the shell

One advantage of =shell-mode= on Windows is that it's the only way to run =cmd.exe=, PowerShell, Git Bash, etc from within Emacs.  Here's an example of how you would set up =shell-mode= to run PowerShell on Windows:

#+begin_src emacs-lisp

  (when (eq system-type 'windows-nt)
    (setq explicit-shell-file-name "powershell.exe")
    (setq explicit-powershell.exe-args '()))

#+end_src

** Eshell
=Eshell= is Emacs' own shell implementation written in Emacs Lisp.  It provides you with a cross-platform implementation (even on Windows!) of the common GNU utilities you would find on Linux and macOS (=ls=, =rm=, =mv=, =grep=, etc).  It also allows you to call Emacs Lisp functions directly from the shell and you can even set up aliases (like aliasing =vim= to =find-file=).  Eshell is also an Emacs Lisp REPL which allows you to evaluate full expressions at the shell.

The downsides to Eshell are that it can be harder to configure than other packages due to the particularity of where you need to set some options for them to go into effect, the lack of shell completions (by default) for some useful things like Git commands, and that REPL programs sometimes don't work as well.  However, many of these limitations can be dealt with by good configuration and installing external packages, so don't let that discourage you from trying it!

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-esh-history= - A searchable history of commands typed into Eshell

We will be covering Eshell more in future videos highlighting other things you can do with it.

For more thoughts on Eshell, check out these articles by Pierre Neidhardt:
- https://ambrevar.xyz/emacs-eshell/index.html
- https://ambrevar.xyz/emacs-eshell-versus-shell/index.html

#+begin_src emacs-lisp

(defun efs/configure-eshell ()
  ;; Save command history when commands are entered
  (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

  ;; Truncate buffer for performance
  (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

  ;; Bind some useful keys for evil-mode
  (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-r") 'counsel-esh-history)
  (evil-define-key '(normal insert visual) eshell-mode-map (kbd "<home>") 'eshell-bol)
  (evil-normalize-keymaps)

  (setq eshell-history-size         10000
        eshell-buffer-maximum-lines 10000
        eshell-hist-ignoredups t
        eshell-scroll-to-bottom-on-input t))

(use-package eshell-git-prompt
  :after eshell)

(use-package eshell
  :hook (eshell-first-time-mode . efs/configure-eshell)
  :config

  (with-eval-after-load 'esh-opt
    (setq eshell-destroy-buffer-when-process-dies t)
    (setq eshell-visual-commands '("htop" "zsh" "vim")))

  (eshell-git-prompt-use-theme 'multiline2))

#+end_src

* File Management
** Dired
Dired is a built-in file manager for Emacs that does some pretty amazing things!  Here are some key bindings you should try out:
*** Key Bindings
**** Navigation
*Emacs* / *Evil*
- =n= / =j= - next line
- =p= / =k= - previous line
- =j= / =J= - jump to file in buffer
- =RET= - select file or directory
- =^= - go to parent directory
- =S-RET= / =g O= - Open file in "other" window
- =M-RET= - Show file in other window without focusing (previewing files)
- =g o= (=dired-view-file=) - Open file but in a "preview" mode, close with =q=
- =g= / =g r= Refresh the buffer with =revert-buffer= after changing configuration (and after filesystem changes!)

**** Marking files
- =m= - Marks a file
- =u= - Unmarks a file
- =U= - Unmarks all files in buffer
- =* t= / =t= - Inverts marked files in buffer
- =% m= - Mark files in buffer using regular expression
- =*= - Lots of other auto-marking functions
- =k= / =K= - "Kill" marked items (refresh buffer with =g= / =g r= to get them back)
- Many operations can be done on a single file if there are no active marks!
 
**** Copying and Renaming files
- =C= - Copy marked files (or if no files are marked, the current file)
- Copying single and multiple files
- =U= - Unmark all files in buffer
- =R= - Rename marked files, renaming multiple is a move!
- =% R= - Rename based on regular expression: =^test= , =old-\&=

*Power command*: =C-x C-q= (=dired-toggle-read-only=) - Makes all file names in the buffer editable directly to rename them!  Press =Z Z= to confirm renaming or =Z Q= to abort.

**** Deleting files
- =D= - Delete marked file
- =d= - Mark file for deletion
- =x= - Execute deletion for marks
- =delete-by-moving-to-trash= - Move to trash instead of deleting permanently

**** Creating and extracting archives
- =Z= - Compress or uncompress a file or folder to (=.tar.gz=)
- =c= - Compress selection to a specific file
- =dired-compress-files-alist= - Bind compression commands to file extension

**** Other common operations
- =T= - Touch (change timestamp)
- =M= - Change file mode
- =O= - Change file owner
- =G= - Change file group
- =S= - Create a symbolic link to this file
- =L= - Load an Emacs Lisp file into Emacs

*** Configuration
#+begin_src emacs-lisp

(use-package dired
  :ensure nil
  :commands (dired dired-jump)
  :bind (("C-x C-j" . dired-jump))
  :custom ((dired-listing-switches "-agho --group-directories-first"))
  :config
  (evil-collection-define-key 'normal 'dired-mode-map
    "h" 'dired-single-up-directory
    "l" 'dired-single-buffer)
  (setq delete-by-moving-to-trash t))

(use-package dired-single
  :after dired)

(use-package all-the-icons-dired
  :hook (dired-mode . all-the-icons-dired-mode))

(use-package dired-open
  :after dired
  :config
  ;; Doesn't work as expected!
  ;;(add-to-list 'dired-open-functions #'dired-open-xdg t)
  (setq dired-open-extensions '(("png" . "feh")
                                ("mkv" . "mpv"))))

(use-package dired-hide-dotfiles
  :hook (dired-mode . dired-hide-dotfiles-mode)
  :config
  (evil-collection-define-key 'normal 'dired-mode-map
    "H" 'dired-hide-dotfiles-mode))

#+end_src


* Runtime Performance

Dial the GC threshold back down so that garbage collection happens more frequently but in less time.

#+begin_src emacs-lisp

  ;; Make gc pauses faster by decreasing the threshold.
  (setq gc-cons-threshold (* 2 1000 1000))

#+end_src
